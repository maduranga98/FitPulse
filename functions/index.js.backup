// ========================================
// Firebase Functions v2 with ES Modules
// ========================================

import { onObjectFinalized } from "firebase-functions/v2/storage";
import {
  onDocumentCreated,
  onDocumentUpdated,
} from "firebase-functions/v2/firestore";
import { initializeApp } from "firebase-admin/app";
import { getFirestore } from "firebase-admin/firestore";
import { getStorage } from "firebase-admin/storage";
import { ImageAnnotatorClient } from "@google-cloud/vision";

// Initialize Firebase Admin
initializeApp();
const db = getFirestore();
const storage = getStorage();

// ========================================
// üîç FACE RECOGNITION WITH MULTI-PHOTO SUPPORT
// ========================================

export const recognizeFace = onObjectFinalized(async (event) => {
  const filePath = event.data.name;
  const bucketName = event.data.bucket;

  console.log("üì∏ New image uploaded:", filePath);

  if (!filePath.startsWith("temp-captures/")) {
    console.log("‚è≠Ô∏è  Skipping - not in temp-captures folder");
    return null;
  }

  try {
    const client = new ImageAnnotatorClient();
    const gcsUri = `gs://${bucketName}/${filePath}`;

    console.log("üîç Detecting face in image...");
    const [result] = await client.faceDetection(gcsUri);
    const faces = result.faceAnnotations;

    if (!faces || faces.length === 0) {
      console.log("‚ùå No face detected in image");
      await storage.bucket(bucketName).file(filePath).delete();
      return null;
    }

    console.log(`‚úÖ Detected ${faces.length} face(s)`);
    const detectedFace = faces[0];

    const filename = filePath.split("/")[1];
    const deviceId = filename.split("_").slice(0, 2).join("_");
    console.log("üì± Device ID:", deviceId);

    console.log("üë• Fetching registered members...");
    const membersSnapshot = await db
      .collection("members")
      .where("faceRegistered", "==", true)
      .get();

    if (membersSnapshot.empty) {
      console.log("‚ö†Ô∏è  No registered members found");
      await storage.bucket(bucketName).file(filePath).delete();
      return null;
    }

    console.log(`üìã Found ${membersSnapshot.size} registered members`);

    let bestMatch = null;
    let highestConfidence = 0;
    let bestMatchDetails = null;

    for (const memberDoc of membersSnapshot.docs) {
      const member = memberDoc.data();

      // ‚úÖ HANDLE BOTH OLD (single photo) AND NEW (multi-photo) FORMATS
      const facePhotos =
        member.facePhotos ||
        (member.facePhotoURL ? [{ url: member.facePhotoURL }] : []);

      if (!facePhotos || facePhotos.length === 0) {
        console.log(`  ‚ö†Ô∏è  ${member.name}: No face photos registered`);
        continue;
      }

      // üì∏ COMPARE WITH ALL STORED PHOTOS FOR THIS MEMBER
      const confidences = [];

      for (let i = 0; i < facePhotos.length; i++) {
        const facePhoto = facePhotos[i];
        const photoUrl = facePhoto.url || facePhoto;

        if (!photoUrl) continue;

        try {
          const [compareResult] = await client.faceDetection(photoUrl);
          const memberFaces = compareResult.faceAnnotations;

          if (!memberFaces || memberFaces.length === 0) {
            console.log(`  ‚ö†Ô∏è  ${member.name}: No face in photo ${i + 1}`);
            continue;
          }

          const memberFace = memberFaces[0];
          const similarity = compareAdvancedFaces(detectedFace, memberFace);

          confidences.push({
            photoIndex: i,
            angle: facePhoto.angle || "unknown",
            confidence: similarity,
          });

          console.log(
            `    Photo ${i + 1} (${facePhoto.angle || "single"}): ${(
              similarity * 100
            ).toFixed(1)}%`
          );
        } catch (error) {
          console.error(
            `  ‚ùå Error comparing with ${member.name} photo ${i + 1}:`,
            error.message
          );
        }
      }

      if (confidences.length === 0) {
        console.log(`  ‚ö†Ô∏è  ${member.name}: No valid comparisons`);
        continue;
      }

      // üéØ SMART MATCHING STRATEGY
      const bestPhotoMatch = Math.max(...confidences.map((c) => c.confidence));

      let avgTopTwo = bestPhotoMatch;
      if (confidences.length >= 2) {
        const sorted = [...confidences].sort(
          (a, b) => b.confidence - a.confidence
        );
        avgTopTwo = (sorted[0].confidence + sorted[1].confidence) / 2;
      }

      let weightedAvg = bestPhotoMatch;
      if (confidences.length >= 2) {
        const sorted = [...confidences].sort(
          (a, b) => b.confidence - a.confidence
        );
        weightedAvg = sorted[0].confidence * 0.6 + sorted[1].confidence * 0.4;
      }

      const finalConfidence = Math.max(bestPhotoMatch, avgTopTwo, weightedAvg);

      console.log(`  üìä ${member.name} final scores:`);
      console.log(`    Best single: ${(bestPhotoMatch * 100).toFixed(1)}%`);
      if (confidences.length >= 2) {
        console.log(`    Avg top 2: ${(avgTopTwo * 100).toFixed(1)}%`);
        console.log(`    Weighted: ${(weightedAvg * 100).toFixed(1)}%`);
      }
      console.log(`    ‚ú® FINAL: ${(finalConfidence * 100).toFixed(1)}%`);

      if (finalConfidence > highestConfidence && finalConfidence > 0.6) {
        highestConfidence = finalConfidence;
        bestMatch = {
          id: memberDoc.id,
          ...member,
        };
        bestMatchDetails = {
          allConfidences: confidences,
          bestPhotoMatch: bestPhotoMatch,
          avgTopTwo: avgTopTwo,
          weightedAvg: weightedAvg,
          photosCompared: confidences.length,
          strategy: "multi-strategy-max",
        };
      }
    }

    if (bestMatch) {
      console.log(`‚úÖ MATCH FOUND: ${bestMatch.name}`);
      console.log(`   Confidence: ${(highestConfidence * 100).toFixed(1)}%`);
      console.log(`   Photos compared: ${bestMatchDetails.photosCompared}`);
      console.log(`   Strategy: ${bestMatchDetails.strategy}`);

      const today = new Date().toISOString().split("T")[0];
      const existingAttendance = await db
        .collection("attendance")
        .where("memberId", "==", bestMatch.id)
        .where("date", "==", today)
        .limit(1)
        .get();

      if (!existingAttendance.empty) {
        console.log("‚ö†Ô∏è  Member already checked in today");
      } else {
        await db.collection("attendance").add({
          memberId: bestMatch.id,
          memberName: bestMatch.name,
          gymId: bestMatch.gymId,
          deviceId: deviceId,
          checkInTime: new Date(),
          date: today,
          confidence: highestConfidence * 100,
          status: "verified",
          recognitionMethod:
            bestMatchDetails.photosCompared > 1
              ? "cloud-vision-multi-photo"
              : "cloud-vision-single",
          matchDetails: {
            photosCompared: bestMatchDetails.photosCompared,
            bestSingleMatch: bestMatchDetails.bestPhotoMatch * 100,
            avgTopTwo: bestMatchDetails.avgTopTwo * 100,
            weightedAvg: bestMatchDetails.weightedAvg * 100,
            strategy: bestMatchDetails.strategy,
            allConfidences: bestMatchDetails.allConfidences.map((c) => ({
              angle: c.angle,
              confidence: (c.confidence * 100).toFixed(1),
            })),
          },
        });

        console.log("‚úÖ Attendance marked successfully!");
      }
    } else {
      console.log("‚ùå No matching member found (confidence too low)");
      console.log(
        `   Highest confidence was: ${(highestConfidence * 100).toFixed(1)}%`
      );
      console.log(`   Threshold: 60.0%`);
    }

    await storage.bucket(bucketName).file(filePath).delete();
    console.log("üóëÔ∏è  Temp file deleted");
  } catch (error) {
    console.error("‚ùå Error processing image:", error);
  }

  return null;
});

// ========================================
// üîß ADVANCED FACE COMPARISON ALGORITHM
// ========================================
function compareAdvancedFaces(face1, face2) {
  let totalScore = 0;
  let totalWeight = 0;

  const detectionWeight = 0.2;
  const avgDetectionConfidence =
    ((face1.detectionConfidence || 0) + (face2.detectionConfidence || 0)) / 2;
  totalScore += avgDetectionConfidence * detectionWeight;
  totalWeight += detectionWeight;

  if (face1.boundingPoly && face2.boundingPoly) {
    const boxWeight = 0.15;
    const boxSimilarity = compareBoundingBoxes(
      face1.boundingPoly.vertices,
      face2.boundingPoly.vertices
    );
    totalScore += boxSimilarity * boxWeight;
    totalWeight += boxWeight;
  }

  const angleWeight = 0.2;
  const angleSimilarity = compareAngles(face1, face2);
  totalScore += angleSimilarity * angleWeight;
  totalWeight += angleWeight;

  if (
    face1.landmarks &&
    face2.landmarks &&
    face1.landmarks.length > 0 &&
    face2.landmarks.length > 0
  ) {
    const landmarkWeight = 0.45;
    const landmarkSimilarity = compareLandmarks(
      face1.landmarks,
      face2.landmarks
    );
    totalScore += landmarkSimilarity * landmarkWeight;
    totalWeight += landmarkWeight;
  }

  const finalSimilarity = totalWeight > 0 ? totalScore / totalWeight : 0;
  return Math.min(1, Math.max(0, finalSimilarity));
}

function compareBoundingBoxes(box1, box2) {
  if (!box1 || !box2 || box1.length < 4 || box2.length < 4) {
    return 0;
  }

  const width1 = Math.abs(box1[1].x - box1[0].x);
  const height1 = Math.abs(box1[2].y - box1[0].y);
  const width2 = Math.abs(box2[1].x - box2[0].x);
  const height2 = Math.abs(box2[2].y - box2[0].y);

  const ratio1 = width1 / height1;
  const ratio2 = width2 / height2;
  const ratioDiff = Math.abs(ratio1 - ratio2);
  const ratioSimilarity = Math.max(0, 1 - ratioDiff);

  return ratioSimilarity;
}

function compareAngles(face1, face2) {
  let angleSimilarity = 0;
  let angleCount = 0;

  const angles = ["rollAngle", "panAngle", "tiltAngle"];

  for (const angle of angles) {
    if (face1[angle] !== undefined && face2[angle] !== undefined) {
      const diff = Math.abs(face1[angle] - face2[angle]);
      const similarity = Math.max(0, 1 - diff / 180);
      angleSimilarity += similarity;
      angleCount++;
    }
  }

  return angleCount > 0 ? angleSimilarity / angleCount : 0.5;
}

function compareLandmarks(landmarks1, landmarks2) {
  const landmarkMap1 = {};
  const landmarkMap2 = {};

  landmarks1.forEach((l) => {
    if (l.type && l.position) {
      landmarkMap1[l.type] = l.position;
    }
  });

  landmarks2.forEach((l) => {
    if (l.type && l.position) {
      landmarkMap2[l.type] = l.position;
    }
  });

  const keyLandmarks = [
    "LEFT_EYE",
    "RIGHT_EYE",
    "NOSE_TIP",
    "UPPER_LIP",
    "LOWER_LIP",
    "LEFT_EYE_PUPIL",
    "RIGHT_EYE_PUPIL",
    "MOUTH_CENTER",
    "LEFT_EAR_TRAGION",
    "RIGHT_EAR_TRAGION",
  ];

  let totalDistance = 0;
  let matchCount = 0;

  for (const landmarkType of keyLandmarks) {
    const pos1 = landmarkMap1[landmarkType];
    const pos2 = landmarkMap2[landmarkType];

    if (pos1 && pos2) {
      const dx = (pos1.x || 0) - (pos2.x || 0);
      const dy = (pos1.y || 0) - (pos2.y || 0);
      const dz = (pos1.z || 0) - (pos2.z || 0);

      const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
      const normalizedDistance = Math.min(1, distance / 250);

      totalDistance += normalizedDistance;
      matchCount++;
    }
  }

  if (matchCount === 0) {
    return 0;
  }

  const avgDistance = totalDistance / matchCount;
  const similarity = Math.max(0, 1 - avgDistance);
  const enhancedSimilarity = 1 / (1 + Math.exp(-10 * (similarity - 0.5)));

  return enhancedSimilarity;
}

// ========================================
// üìù PROCESS FACE REGISTRATION (Multi-Photo)
// ========================================
export const processFaceRegistration = onDocumentUpdated(
  "members/{memberId}",
  async (event) => {
    const newData = event.data.after.data();
    const oldData = event.data.before.data();

    if (!newData.facePhotos || oldData.facePhotos) {
      return null;
    }

    console.log(
      "üì∏ Processing multi-photo face registration for:",
      newData.name
    );

    try {
      const client = new ImageAnnotatorClient();
      const processedPhotos = [];

      for (let i = 0; i < newData.facePhotos.length; i++) {
        const photo = newData.facePhotos[i];

        console.log(
          `  Processing photo ${i + 1}/${newData.facePhotos.length} (${
            photo.angle
          })`
        );

        const [result] = await client.faceDetection(photo.url);
        const faces = result.faceAnnotations;

        if (!faces || faces.length === 0) {
          console.log(`  ‚ö†Ô∏è  No face detected in photo ${i + 1}`);
          processedPhotos.push({
            ...photo,
            processed: false,
            error: "No face detected",
          });
          continue;
        }

        const faceData = faces[0];

        processedPhotos.push({
          ...photo,
          processed: true,
          detectionConfidence: faceData.detectionConfidence,
          landmarksCount: faceData.landmarks ? faceData.landmarks.length : 0,
          rollAngle: faceData.rollAngle,
          panAngle: faceData.panAngle,
          tiltAngle: faceData.tiltAngle,
          processedAt: new Date().toISOString(),
        });

        console.log(
          `  ‚úÖ Photo ${i + 1} processed - Confidence: ${(
            faceData.detectionConfidence * 100
          ).toFixed(1)}%`
        );
      }

      const successfulPhotos = processedPhotos.filter(
        (p) => p.processed
      ).length;

      await event.data.after.ref.update({
        facePhotos: processedPhotos,
        facePhotosProcessed: successfulPhotos,
        facePhotosFailed: processedPhotos.length - successfulPhotos,
        faceEnrolledAt: new Date(),
      });

      console.log(
        `‚úÖ Face registration completed: ${successfulPhotos}/${processedPhotos.length} photos successful`
      );
    } catch (error) {
      console.error("‚ùå Error processing face registration:", error);

      await event.data.after.ref.update({
        faceRegistrationError: error.message,
      });
    }

    return null;
  }
);

// ========================================
// üîÑ BACKWARDS COMPATIBILITY - OLD SINGLE PHOTO
// ========================================
export const processSingleFaceRegistration = onDocumentCreated(
  "members/{memberId}",
  async (event) => {
    const member = event.data.data();

    if (member.facePhotos || !member.facePhotoURL || !member.faceRegistered) {
      return null;
    }

    console.log(
      "üì∏ Processing single-photo face registration for:",
      member.name
    );

    try {
      const client = new ImageAnnotatorClient();
      const [result] = await client.faceDetection(member.facePhotoURL);
      const faces = result.faceAnnotations;

      if (!faces || faces.length === 0) {
        console.log("‚ùå No face detected in registration photo");

        await event.data.ref.update({
          faceRegistered: false,
          faceRegistrationError: "No face detected in photo",
        });

        return null;
      }

      const faceData = faces[0];

      await event.data.ref.update({
        faceDetectionConfidence: faceData.detectionConfidence,
        faceLandmarksCount: faceData.landmarks ? faceData.landmarks.length : 0,
        faceRollAngle: faceData.rollAngle,
        facePanAngle: faceData.panAngle,
        faceTiltAngle: faceData.tiltAngle,
        faceEnrolledAt: new Date(),
      });

      console.log("‚úÖ Single-photo registration processed successfully");
      console.log(
        `   Detection confidence: ${(
          faceData.detectionConfidence * 100
        ).toFixed(1)}%`
      );
    } catch (error) {
      console.error("‚ùå Error processing face registration:", error);

      await event.data.ref.update({
        faceRegistrationError: error.message,
      });
    }

    return null;
  }
);
