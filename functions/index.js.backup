import { storage, firestore } from "firebase-functions";
import {
  initializeApp,
  storage as _storage,
  firestore as _firestore,
} from "firebase-admin";
import { ImageAnnotatorClient } from "@google-cloud/vision";

initializeApp();

export const recognizeFace = storage.object().onFinalize(async (object) => {
  const filePath = object.name;
  const bucketName = object.bucket;

  console.log("üì∏ New image uploaded:", filePath);

  if (!filePath.startsWith("temp-captures/")) {
    console.log("‚è≠Ô∏è  Skipping - not in temp-captures folder");
    return null;
  }

  try {
    const client = new ImageAnnotatorClient();
    const gcsUri = `gs://${bucketName}/${filePath}`;

    console.log("üîç Detecting face in image...");
    const [result] = await client.faceDetection(gcsUri);
    const faces = result.faceAnnotations;

    if (!faces || faces.length === 0) {
      console.log("‚ùå No face detected in image");
      await _storage().bucket(bucketName).file(filePath).delete();
      return null;
    }

    console.log(`‚úÖ Detected ${faces.length} face(s)`);
    const detectedFace = faces[0];

    const filename = filePath.split("/")[1];
    const deviceId = filename.split("_").slice(0, 2).join("_");
    console.log("üì± Device ID:", deviceId);

    console.log("üë• Fetching registered members...");
    const db = _firestore();
    const membersSnapshot = await db
      .collection("members")
      .where("faceRegistered", "==", true)
      .get();

    if (membersSnapshot.empty) {
      console.log("‚ö†Ô∏è  No registered members found");
      await _storage().bucket(bucketName).file(filePath).delete();
      return null;
    }

    console.log(`üìã Found ${membersSnapshot.size} registered members`);

    let bestMatch = null;
    let highestConfidence = 0;

    for (const memberDoc of membersSnapshot.docs) {
      const member = memberDoc.data();

      if (!member.facePhotoURL) {
        continue;
      }

      try {
        const [compareResult] = await client.faceDetection(member.facePhotoURL);
        const memberFaces = compareResult.faceAnnotations;

        if (!memberFaces || memberFaces.length === 0) {
          console.log(`  ‚ö†Ô∏è  ${member.name}: No face in stored photo`);
          continue;
        }

        const memberFace = memberFaces[0];
        const similarity = compareAdvancedFaces(detectedFace, memberFace);

        console.log(
          `  Comparing with ${member.name}: ${(similarity * 100).toFixed(1)}%`
        );

        if (similarity > highestConfidence && similarity > 0.6) {
          highestConfidence = similarity;
          bestMatch = {
            id: memberDoc.id,
            ...member,
          };
        }
      } catch (error) {
        console.error(
          `  ‚ùå Error comparing with ${member.name}:`,
          error.message
        );
      }
    }

    if (bestMatch) {
      console.log(
        `‚úÖ MATCH FOUND: ${bestMatch.name} (${(highestConfidence * 100).toFixed(
          1
        )}% confidence)`
      );

      const today = new Date().toISOString().split("T")[0];
      const existingAttendance = await db
        .collection("attendance")
        .where("memberId", "==", bestMatch.id)
        .where("date", "==", today)
        .limit(1)
        .get();

      if (!existingAttendance.empty) {
        console.log("‚ö†Ô∏è  Member already checked in today");
      } else {
        await db.collection("attendance").add({
          memberId: bestMatch.id,
          memberName: bestMatch.name,
          gymId: bestMatch.gymId,
          deviceId: deviceId,
          checkInTime: _firestore.FieldValue.serverTimestamp(),
          date: today,
          confidence: highestConfidence * 100,
          status: "verified",
          recognitionMethod: "cloud-vision-improved",
        });

        console.log("‚úÖ Attendance marked successfully!");
      }
    } else {
      console.log("‚ùå No matching member found (confidence too low)");
      console.log(
        `   Highest confidence was: ${(highestConfidence * 100).toFixed(1)}%`
      );
    }

    await _storage().bucket(bucketName).file(filePath).delete();
    console.log("üóëÔ∏è  Temp file deleted");
  } catch (error) {
    console.error("‚ùå Error processing image:", error);
  }

  return null;
});

function compareAdvancedFaces(face1, face2) {
  let totalScore = 0;
  let totalWeight = 0;

  const detectionWeight = 0.2;
  const avgDetectionConfidence =
    ((face1.detectionConfidence || 0) + (face2.detectionConfidence || 0)) / 2;
  totalScore += avgDetectionConfidence * detectionWeight;
  totalWeight += detectionWeight;

  if (face1.boundingPoly && face2.boundingPoly) {
    const boxWeight = 0.15;
    const boxSimilarity = compareBoundingBoxes(
      face1.boundingPoly.vertices,
      face2.boundingPoly.vertices
    );
    totalScore += boxSimilarity * boxWeight;
    totalWeight += boxWeight;
  }

  const angleWeight = 0.2;
  const angleSimilarity = compareAngles(face1, face2);
  totalScore += angleSimilarity * angleWeight;
  totalWeight += angleWeight;

  if (
    face1.landmarks &&
    face2.landmarks &&
    face1.landmarks.length > 0 &&
    face2.landmarks.length > 0
  ) {
    const landmarkWeight = 0.45;
    const landmarkSimilarity = compareLandmarks(
      face1.landmarks,
      face2.landmarks
    );
    totalScore += landmarkSimilarity * landmarkWeight;
    totalWeight += landmarkWeight;
  }

  const finalSimilarity = totalWeight > 0 ? totalScore / totalWeight : 0;
  return Math.min(1, Math.max(0, finalSimilarity));
}

function compareBoundingBoxes(box1, box2) {
  if (!box1 || !box2 || box1.length < 4 || box2.length < 4) {
    return 0;
  }

  const width1 = Math.abs(box1[1].x - box1[0].x);
  const height1 = Math.abs(box1[2].y - box1[0].y);
  const width2 = Math.abs(box2[1].x - box2[0].x);
  const height2 = Math.abs(box2[2].y - box2[0].y);

  const ratio1 = width1 / height1;
  const ratio2 = width2 / height2;
  const ratioDiff = Math.abs(ratio1 - ratio2);
  const ratioSimilarity = Math.max(0, 1 - ratioDiff);

  return ratioSimilarity;
}

function compareAngles(face1, face2) {
  let angleSimilarity = 0;
  let angleCount = 0;

  const angles = ["rollAngle", "panAngle", "tiltAngle"];

  for (const angle of angles) {
    if (face1[angle] !== undefined && face2[angle] !== undefined) {
      const diff = Math.abs(face1[angle] - face2[angle]);
      const similarity = Math.max(0, 1 - diff / 180);
      angleSimilarity += similarity;
      angleCount++;
    }
  }

  return angleCount > 0 ? angleSimilarity / angleCount : 0.5;
}

function compareLandmarks(landmarks1, landmarks2) {
  const landmarkMap1 = {};
  const landmarkMap2 = {};

  landmarks1.forEach((l) => {
    if (l.type && l.position) {
      landmarkMap1[l.type] = l.position;
    }
  });

  landmarks2.forEach((l) => {
    if (l.type && l.position) {
      landmarkMap2[l.type] = l.position;
    }
  });

  const keyLandmarks = [
    "LEFT_EYE",
    "RIGHT_EYE",
    "NOSE_TIP",
    "UPPER_LIP",
    "LOWER_LIP",
    "LEFT_EYE_PUPIL",
    "RIGHT_EYE_PUPIL",
    "MOUTH_CENTER",
    "LEFT_EAR_TRAGION",
    "RIGHT_EAR_TRAGION",
  ];

  let totalDistance = 0;
  let matchCount = 0;

  for (const landmarkType of keyLandmarks) {
    const pos1 = landmarkMap1[landmarkType];
    const pos2 = landmarkMap2[landmarkType];

    if (pos1 && pos2) {
      const dx = (pos1.x || 0) - (pos2.x || 0);
      const dy = (pos1.y || 0) - (pos2.y || 0);
      const dz = (pos1.z || 0) - (pos2.z || 0);

      const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
      const normalizedDistance = Math.min(1, distance / 250);

      totalDistance += normalizedDistance;
      matchCount++;
    }
  }

  if (matchCount === 0) {
    return 0;
  }

  const avgDistance = totalDistance / matchCount;
  const similarity = Math.max(0, 1 - avgDistance);
  const enhancedSimilarity = 1 / (1 + Math.exp(-10 * (similarity - 0.5)));

  return enhancedSimilarity;
}

export const processFaceRegistration = firestore
  .document("members/{memberId}")
  .onCreate(async (snap) => {
    const member = snap.data();

    if (!member.facePhotoURL || !member.faceRegistered) {
      return null;
    }

    console.log("üì∏ Processing face registration for:", member.name);

    try {
      const client = new ImageAnnotatorClient();
      const [result] = await client.faceDetection(member.facePhotoURL);
      const faces = result.faceAnnotations;

      if (!faces || faces.length === 0) {
        console.log("‚ùå No face detected in registration photo");

        await snap.ref.update({
          faceRegistered: false,
          faceRegistrationError: "No face detected in photo",
        });

        return null;
      }

      const faceData = faces[0];

      await snap.ref.update({
        faceDetectionConfidence: faceData.detectionConfidence,
        faceLandmarksCount: faceData.landmarks ? faceData.landmarks.length : 0,
        faceRollAngle: faceData.rollAngle,
        facePanAngle: faceData.panAngle,
        faceTiltAngle: faceData.tiltAngle,
        faceEnrolledAt: _firestore.FieldValue.serverTimestamp(),
      });

      console.log("‚úÖ Face registration processed successfully");
      console.log(
        `   Detection confidence: ${(
          faceData.detectionConfidence * 100
        ).toFixed(1)}%`
      );
    } catch (error) {
      console.error("‚ùå Error processing face registration:", error);

      await snap.ref.update({
        faceRegistrationError: error.message,
      });
    }

    return null;
  });
